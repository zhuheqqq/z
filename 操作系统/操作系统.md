# 操作系统

抽象、并行、隔离、共享、访问控制系统、良好的性能、支持多个应用程序

子程序调用和中断(进入内核)的区别?

内核在机器启动时加载，具有特权，有关于硬件的特权，但是普通函数调用没有

## 操作系统结构

**隔离**：内核模式和用户模式

如果只有一个CPU,不管应用程序在干什么，必须每隔一段时间强制他放弃CPU,使得其他应用程序可以运行

**内存隔离**：使得一个应用程序不会覆盖另一个应用程序，如果不使用操作系统，应用程序直接访问硬件是很难达到隔离的。控制了应用程序和物理硬件之间的交互

接口抽象了硬件资源，让提供强隔离成为可能

应用程序不能直接访问CPU，而是通过进程抽象，使得内核可以在进程之间切换，操作系统提供进程作为对CPU的抽象，所以操作系统可以复用一个或多个CPU到多个应用程序

**CPU时间复用**：一个应用程序使用CPU一段时间，然后另一个应用程序使用一段时间

文件是对磁盘块的抽象，而不是直接读写磁盘上的磁盘块，访问存储系统的唯一方式就是通过文件

**缓存亲和性**：避免缓存缺失来优化性能

**defensive**：操作系统必须防止应用程序破坏操作系统，可以处理恶意应用程序。另一个是应用程序不能打破它的隔离，应用程序和操作系统之间必须有强隔离。

实现强隔离的常用方法是硬件支持，一般有两种硬件支持。一种是内核模式/kernel模式（管理者模式），一种是页表（虚拟内存）。

### 宏观的用户内核模式

当运行在内核模式时，CPU可以运行特权指令。当运行在用户模式时，CPU只能执行非特权指令。特权指令是引入直接操作硬件的指令、设置保护或类似的东西。

处理器中存在一个标志判断是否是用户模式或者是内核模式，一般1是用户模式，0是内核模式。当处理器解码指令时，检查操作码，如果操作码是特权指令并且那个位设置为1,就会拒绝该指令

### 页表

**页表就是将虚拟地址映射到物理地址**。基本思想是给每个进程提供自己的页表，使用这种方式进程只能访问它的页表中显示的物理地址，无法访问到别的进程的物理地址，所以这提供了强内存隔离。页表定义了内存布局，每个用户进程都有自己的内存布局，相互独立。

### ecall指令

ecall指令接受一个参数一个数字，所以当用户程序想要将控制权转移到内核时，调用ecall指令，使用数字，这个数字就是应用程序想要访问的系统调用编号。这个指令会进入内核中的一个由内核控制的特定位置。在一些系统中，有一个单独的系统调用入口位置，每次应用程序调用ecall,应用程序进入内核的特定位置。

比如调用fork函数，并不会直接调用系统调用，而是调用ecall，使用fork的系统调用编号，然后进入内核。用户程序调用fork的唯一方式是通过ecall指令。

内核如何从用户程序中夺回控制权？

内核对硬件编程设置一个定时器，在定时器结束之后，会触发从用户空间切换到内核模式，在这个时间点，内核重新获得控制权，然后重新调度CPU给其他进程

## 内核如何编译

proc.c->通过gcc编译器->proc.S->汇编器->proc.o(汇编程序的二进制版本)->加载器使用所有不同文件生成的.o文件，将他们链接在一起生成kernel