

# **《LINUX系统编程笔记》**

[TOC]



## LINUX内核

### LINUX内核2.6发布后所确定的基本细节

1.不再有稳定内核和开发内核的概念。每个新的 2.6.z 发布版都可以包含新特性，其生命周期始于对新特性的追加，然后历经一系列候选发布版本让新特性稳定下来。当开发者认为某个候选版本足够稳定时，便可将其作为内核 2.6.z 发布。一般情况下，发布周期约为 3 个月。

2.有时，也可能需要为某个稳定的 2.6.z 发布版打上些小补丁程序，以修复 bug 或安全问题。如果这样的修复工作具有足够高的优先级，并且补丁程序的正确性也“毋庸置疑”，那么无需等待下一个 2.6.z 发布版，可以直接应用补丁创建一个本号形如 2.6.z.r 的发布版本，其中，r 作为该 2.6.z 内核版本的次修订版序号。

3.额外责任将转嫁给Linux 发行厂商，由他们来确保随Linux 发行版一同发行内核的稳定性。本书后续各章有时会提及 API 发生特定变化（比如，新增了系统调用或者系统调用发生变化时）的相应内核版本。在 2.6.z 系列之前，虽然大多数内核变化都见诸于具有奇数版本号的开发分支，但本书通常所指的是那些变化初次出现的稳定内核版本，这是因为大多数应用开发者一般都会使用稳定版的内核，而非开发版本。很多情况下，手册页会注明某一具体特性出现或发生变化时开发版内核的确切版本号

### 术语LINUX解释

准确说来，术语 Linux 只是指由 Linus Torvalds 和其他人所开发出的内核。可是，也常使用该术语来指代**内核外加一大堆其他软件（工具和库）所构成的完整操作系统。**



------



## 基本概念

### 栈和堆

栈由操作系统自动分配释放，用于存放函数的参数值、局部变量等。

堆由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表

### 操作系统和内核

术语“操作系统”通常包含两种不同含义。
1．指完整的软件包，这包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文本编辑器等。
2．在更狭义的范围内，是指管理和分配计算机资源（即CPU、RAM 和设备）的核心层软件。
术语“内核”通常是第二种含义。

> 一般情况下，Linux 内核可执行文件采用/boot/vmlinuz 或与之类似的路径名。而文件名的来历也颇有渊源。早期的 UNIX 实现称其内核为 UNIX。在后续实现了虚拟内存机制的 UNIX 系统中，其内核名称变更为 vmunix。 对 Linux 来说，文件名称中的系统名需要调整，而以“z”替换“linux”末尾的“x”，意在表明内核是经过压缩的可执行文件。

### 内核的职责

- 进程调度：**计算机内均配备有一个或多个 CPU（中央处理单元），以执行程序指令。**与其他 UNIX 系统一样，Linux 属于抢占式多任务操作系统。“**多任务”意指多个进程（即运行中的程序）可同时驻留于内存，且每个进程都能获得对 CPU 的使用权**。“抢占”则是指一组规则。这组规则**控制着哪些进程获得对 CPU 的使用，以及每个进程能使用多长时间，**这两者都由内核进程调度程序（而非进程本身）决定。
- 内存管理：物理内存（RAM）属于有限资源，**内核必须以公平、高效地方式在进程间共享这一资源**。与大多数现代操作系统一样，Linux也采用了虚拟内存管理机制（6.4 节 ），这项技术主要具有以下两方面的优势。
   -进程与进程之间、进程与内核之间彼此隔离，因此一个进程无法读取或修改内核或其他进程的内存内容。
   -只需将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在 RAM 中同时加载更多的进程。这也大幅提升了如下事件的发生概率，在任一时刻，CPU 都有至少一个进程可以执行，从而使得对 CPU 资源的利用更加充分。
- 提供了文件系统：内核在磁盘之上提供有文件系统，允许**对文件执行创建、获取、更新以及删除等**操作。
- 创建和终止进程：**内核可将新程序载入内存，为其提供运行所需的资源**（比如，CPU、内存以及对文件的访问等）。**这样一个运行中的程序我们称之为“进程”。**一旦进程执行完毕，内核还要确保释放其占用资源，以供后续程序重新使用。
- 对设备的访问：计算机外接设备（鼠标、键盘、磁盘和磁带驱动器等）可实现计算机与外部世界的通信，这一通信机制包括输入、输出或是两者兼而有之。内核既为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问。
- 联网：**内核以用户进程的名义收发网络消息（数据包）**。该任务包括将网络数据包路由至目标系统。
- 提供系统调用应用编程接口（API）：进程**可利用内核入口点**（也称为系统调用）请求内核去执行各种任务。
- 虚拟私有计算机（virtual private computer）：**这就是说，每个用户都可以登录进入系统，独立操作，而与其他用户大致无干。**例如，每个用户都有属于自己的磁盘存储空间（主目录）。再者，用户能够运行程序，而每一程序都能从 CPU 资源中“分得一杯羹”，运转于自有的虚拟地址空间中。而且这些程序还能独立访问设备，并通过网络传递信息。内核负责
  解决（多进程）访问硬件资源时可能引发的冲突，用户和进程对此则往往一无所知。

### 内核态和用户态

现代处理器架构一般允许 CPU 至少在两种不同状态下运行，执行硬件指令可使 C P U 在两种状态间来回切换。

- 用户态：在用户态下运行时，CPU 只 能 访 问 被 标 记 为 用 户 空 间 的 内 存 ，试 图 访 问 属 于 内 核 空 间 的 内 存 会 引 发 硬件异常。
- 内核态：当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存。仅当处理器在核心态运行时，才能执行某些特定操作。这样的例子包括：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备 I/O 操作的初始化等

### shell

shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。

### 用户和组

系统会对每个用户的身份做唯一标识，用户可隶属于多个组。

用户：系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户ID（UID）。系统密码文件/etc/passwd 为每个用户都定义有一行记录，除了上述两项信息外，该记录还包含如下信息。

- 组 ID：用户所属第一个组的整数型组 ID。
- 主目录：用户登录后所居于的初始目录。
- 登录 shell：执行以解释用户命令的程序名称。

组：为了控制对文件和其他资源的访问，将多个用户分组。每个用户
组都对应着系统组文件/etc/group 中的一行记录，该记录包含如下信息。

- 组名：（唯一的）组名称。
- 组 ID（GID）：与组相关的整数型 ID。
- 用户列表：隶属于该组的用户登录名列表（通过密码文件记录的 group ID 字段未能标识出的该组其他成员，也在此列），以逗号分隔。

超级用户：超级用户在系统中享有特权。超级用户账号的用户 ID 为 0，通常登录名为 root。在一般的 UNIX 系统上，超级用户凌驾于系统的权限检查之上。

### 单根目录层级

内核维护着一套单根目录结构，以放置系统的所有文件。这一目录层级的根基就是名为“/”的根目录。所有的文件和目录都是根目录的“子孙”。

### 文件类型

一种表示**普通数据文件**，人们常称之为“普通文件”或“**纯文本文件**”，以示与其他种类的文件有所区别。

**其他文件类型**包括设备、管道、套接字、目录以及符号链接。

术语“文件”常用来指代任意类型的文件，不仅仅指普通文件

### 目录和链接

链接：文件名+引用

目录：目录是一种特殊类型的文件，内容采用表格形式，数据项包括文件名以及对相应文件的引用。

目录可包含指向文件或其他目录的链接。

每个目录至少包含两条记录：.和..，**前者是指向目录自身的链接，后者是指向其上级目录—父目录的链接**。除根目录外，每个目录都有父目录。对于根目录而言，..是指向根目录自身的链接（因此，/..等于/）。

**根目录下是子目录，子目录下又有文件或目录**

### 符号链接

硬链接（hard link）：正常链接。是内容为“文件名+指针”的一条记录。

软链接（soft link）：符号链接。符号链接则是经过特殊标记的文件，内容包
含了另一文件的名称。（换言之，一个符号链接对应着目录中内容为“文件名+指针”的一条记录，指针指向的文件内容为另一个文件名的字符串。）      在多数情况下，只要系统调用用到了路径名，内核会自动解除（换言之，按照）该路径名中符号链接的引用，以符号链接所指向的文件名来替换符号链接。      若符号链接的目标文件自身也是一个符号链接，那么上述过程会以递归方式重复下去。    如果符号链接指向的文件并不存在，那么可将该链接视为空链接（dangling link）。

### 文件名

在大多数 Linux 文件系统上，文件名最长可达 255 个字符。文件名可以包除“/”和空字符（\0）外的所有字符。但是，只建议使用字母、数字、点(“.”)、下划线（“_”）以及连字符（“−”）。

如 在 上 述 环 境 中 出 现 了 包 含 特 殊 含 义 字 符 的文件名，则需要进行转义，即对此类字符进行特殊标记（一般会在特殊字符前插入一个“\”），以指明不应以特殊含义对其进行解释。若场境不支持转义机制，则不能使用此类文件名。

此外，还应避免以连字符（“-”）作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。

### 路径名

路径名是由一系列文件名组成的字符串，彼此以“/”分隔，首字符可以为“/”。除却最后一个文件名外，该系列文件名均为目录名称。    有时将该字符串中最后一个“/”字符之前的部分称为路径名的目录部分，将其之后的部分称为路径名的文件部分或基础部分。

路径名应按从左至右的顺序阅读，路径名中每个文件名之前的部分，即为该文件所处目录。可在路径名中任意位置后引入字符串“..”，用以指代路径名中当前位置的父目录。
路径名描述了单根目录层级下的文件位置，又可分为绝对路径名和相对路径名：

- 绝对路径名以“/”开始，指明文件相对于根目录的位置。
- 相对路径名定义了相对于进程当前工作目录（见下文）的文件位置，与绝对路径名相比，相对路径名缺少了起始的“/”。

### 当前工作目录

每个进程都有一个当前工作目录（有时简称为进程工作目录或当前目录）。这就是单根目录层级下进程的“当前位置”，也是进程解释相对路径名的参照点。

可使用 cd 命令来改变 shell 的当前工作目录。

### I/O 通用性概念(input and output)

同一套系统调用（open()、read()、write()、close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。

内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设
备时，可通过 lseek()系统调用来随机访问。

许多应用程序和函数库都将新行符（十进制 ASCII 码为 10，有时亦称其为换行）视为文本中一行的结束和另一行的开始。UNIX 系统没有文件结束符的概念，读取文件时如无数据返回，便会认定抵达文件末尾。

### 文件描述符

I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。       由 shell 启动的进程会继承 3 个已打开的文件描述符：描述符 0 为标准输入，指代为进程提供输入的文件，**与stdin函数对应**；描述符 1 为标准输出，指代供进程写入输出的文件，**与stdout函数对应**；描述符 2 为标准错误，指代供进程写入错误消息或异常通告的文件，**与stdin函数对应**。

### 程序

程序通常以两种面目示人。其一为源码形式，由使用编程语言（比如，C 语言）写成的一系列语句组成，是人类可以阅读的文本文件。要想执行程序，则需将源码转换为第二种形式—计算机可以理解的二进制机器语言指令。

### 过滤器

从 stdin 读取输入，加以转换，再将转换后的数据输出到 stdout，常常将拥有上述行为的程序称为过滤器，cat、grep、tr、sort、wc、sed、awk 均在其列。

### 命令行参数

C 语言程序可以访问命令行参数，即程序运行时在命令行中输入的内容。要访问命令行参数，程序的 main()函数需做如下声明：

```c
int main(int argc,char *argv[])
```

argc 变量包含命令行参数的总个数，argv 指针数组的成员指针则逐一指向每个命令行参数字符串。首个字符串 argv[0]，标识程序名本身。

### 进程

进程是正在执行的程序实例。

### 进程的内存布局

- 文本：程序的指令。
- 数据：程序使用的静态变量。
- 堆：程序可从该区域动态分配额外内存。
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。

### 创建进程和执行程序

进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。      内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）

进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的
情况是使用系统调用 execve()去加载并执行一个全新程序。execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们

### 进程 ID 和父进程 ID 

每一进程都有一个唯一的整数型进程标识符（PID）。     此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。

### init进程

系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。     系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。init 进程的进程号总为 1，且总是以超级用户权限运行。      谁（哪怕是超级用户）都不能“杀死”init 进程，只有关闭系统才能终止该进程。init 的主要任务是创建并监控系统运行所需的一系列进程。

### 守护进程

守护进程指的是具有特殊用途的进程。特征有：

- “长生不老”。
- 守护进程在后台运行，且无控制终端供其读取或写入数据。

### 资源限制

每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。

软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。

由 fork()创建的新进程，会继承其父进程对资源限制的设置。

使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。shell 为执行命令所创建的子进程会继承上述资源设置

### 内存映射

调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。
映射分为两类。

- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。
- 相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

由某一进程所映射的内存可以与其他进程的映射共享，共享方式如下：

- 两个进程都针对某一文件的相同部分加以映射
- 由 fork()创建的子进程自父进程处继承映射。

若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动

### 静态库和共享库

目标库：将（通常是逻辑相关的）一组函数代码加以编译，并置于一个文件中，供其他应用程序调用。

静态库：静态库是对已编译目标模块的一种结构化整合。要使用静态库中的函数，需要在创建程序的链接命令中指定相应的库。     对于所需库内的各目标模块，采用静态链接方式生成的程序都存有一份副本。这可能会造成磁盘空间的浪费和内存浪费。另外，如果对库函数进行了修改，需要重新加以编译、生成新的静态库，而所有需要调用该函数“更新版”的应用，都必须与新生成的静态库重新链接。

共享库：设计共享库的目的是为了解决静态库所存在的问题。       如果将程序链接到共享库，那么链接器就不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库。一旦在运行时将可执行文件载入内存，一款名为“动态链接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中相应的函数定义关联起来。在运行时，共享库代码在内存中只需保留一份，且可供所有运行中的程序使用。

### 进程间通信及同步

Linux 提供了丰富的进程间通信（IPC）机制。

- 信号（signal），用来表示事件的发生。
- 管道（亦即 shell 用户所熟悉的“|”操作符）（是最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递）和 FIFO，用于在进程间传递数据。
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
- 消息队列，用于在进程间交换消息（数据包）。
- 信号量（semaphore），用来同步进程动作。
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。

### 信号

人们往往将信号称为“软件中断”。进程收到信号，就意味着某一事件或异常情况的发生。

内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。例如，发生下列情况之一时，内核可向进程发送信号。

- 用户键入中断字符（通常为 Control-C）。
- 进程的子进程之一已经终止。
- 由进程设定的定时器（告警时钟）已经到期。
- 进程尝试访问无效的内存地址。

在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。
收到信号时，进程会根据信号采取如下动作之一

- 忽略信号。
- 被信号“杀死”。
- 先挂起，之后再被专用信号唤醒。

就大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。

信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。

### 线程

可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。

线程之间可通过共享的全局变量进行通信。           线程的主要优点在于协同线程之间的数据共享（通过全局变量）更为容易，而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然。

### 伪终端

伪终端是一对相互连接的虚拟设备，也称为主从设备。在这对设备之间，设有一条 IPC信道，可供数据进行双向传递。

### 日期和时间

- 真实时间：指的是在进程的生命期内（所经历的时间或时钟时间），以某个标准时间点（日历时间）或固定时间点（通常是进程的启动时间）为起点测量得出的时间。
- 进程时间：亦称为 CPU 时间，指的是进程自启动起来，所占用的 CPU 时间总量。可进一步将 CPU 时间划分为系统 CPU 时间和用户 CPU 时间。         前者是指在内核模式中，执行代码所花费的时间（比如，执行系统调用，或代表进程执行其他的内核服务）。后者是指在用户模式中，执行代码所花费的时间（比如，执行常规的程序代码）。

### 客户端/服务器架构

- 客户端：向服务器发送请求消息，请求服务器执行某些服务。
- 服务器：分析客户端的请求，执行相应的动作，然后，向客户端回发响应消息。

服务器可提供的服务：

- 提供对数据库或其他共享信息资源的访问。
- 提供对远程文件的跨网访问。
- 对某些商业逻辑进行封装。
- 提供对共享硬件资源的访问（比如，打印机）。
- 提供 WWW 服务。

###  /proc 文件系统

/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。

------

## 系统编程概念

### 系统调用

系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作。

- 系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。
- 系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。（程序通过名称来标识系统调用，对这一编号方案往往一无所知。）
- 每个系统调用可辅之以一套参数，对用户空间（亦即进程的虚拟地址空间）与内核空间之间（相互）传递的信息加以规范。

系统调用步骤：

1. 应用程序通过调用 C 语言函数库中的外壳（wrapper）函数，来发起系统调用。
2. 对系统调用中断处理例程（稍后介绍）来说，外壳函数必须保证所有的系统调用参数可用。通过堆栈，这些参数传入外壳函数，但内核却希望将这些参数置入特定寄存器。因此，外壳函数会将上述参数复制到寄存器。
3. 由于所有系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函数会将系统调用编号复制到一个特殊的 CPU 寄存器（%eax）中。
4. 外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断 0x80 (十进制数 128)的中断矢量所指向的代码。
5. 为响应中断 0x80，内核会调用 system_call()例程（位于汇编文件 arch/i386/entry.S 中）来
   处理这次中断，具体如下。
   a）在内核栈中保存寄存器值（参见 6.5 节）。
   b）审核系统调用编号的有效性。
   c）以系统调用编号对存放所有调用服务例程的列表（内核变量 sys_call_table）进行索引，发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检查参数的有效性。例如，会检查地址指向用户空间的内存位置是否有效。随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改，以及在用户内存和内核内存间传递数据（比如，在 I/O 操作中）。最后，该服务例程会将结果状态返回给 system_call()例程。
   d）从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中。
   e）返回至外壳函数，同时将处理器切换回用户态。
6. 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno（参见 3.4 节）。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。     在 Linux 上，系统调用服务例程遵循的惯例是调用成功则返回非负值。发生错误时，例程会对相应 errno 常量取反，返回一负值。C 语言函数库的外壳函数随即对其再次取反（负负得正），将结果拷贝至 errno，同时以-1 作为外壳函数的返回值返回，向调用程序表明有错误发生。

从 C 语言编程的角度来看，调用 C 语言函数库的外壳（wrapper）函数等同于调用
相应的系统调用服务例程，在本书后续内容中，“调用系统调用 xyz()”这类说法就意味着“调用外壳函数，由外壳函数去调用系统调用 xyz()”。

### 库函数

一个库函数是构成标准 C 语言函数库的众多库函数之一。许多库函数（比如，字符串操作函数）不会使用任何系统调用。

### 命令行选项及参数

传统的 UNIX 命令行选项由一个连字符（-）、表示选项的英文字母，以及一个可选参数组成。

## 文件 I/O：通用的 I/O 模型

### 执行文件 I/O 操作的 4 个主要系统调用

- fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式：只读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限，如 果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。
-  numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count字节的数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节可读（例如：读到文件结尾符 EOF 时），则返回值为 0。
-  numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可能小于 count。
-  status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及与之相关的内核资源。

### 通用I/O

UNIX I/O 模型的显著特点之一是其输入/输出的通用性概念。这意味着使用 4 个同样的系统调用 open()、read()、write()和 close()可以对所有类型的文件执行 I/O 操作，包括终端之类的设备。因此，仅使用这些系统调用编写的程序，将对任何类型的文件有效。

### OPEN(const char*pathname,int flags,.../ * mode_t mode*/)

open()调用既能打开一个业已存在的文件，也能创建并打开一个新文件。

文件访问模式:

- O_RDONLY   以只读方式打开文件   r
- O_WRONLY  以只写方式打开文件  w
- O_RDWR        以读写方式打开文件  rw

open()调用所返回的文件描述符数值:   如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最小者。可以利用该特性以特定文件描述符打开某一文件。

### flags 常量的详细描述

- O_APPEND  总是在文件尾部追加数据
- O_ASYNC   当对于 open()调用所返回的文件描述符可以实施 I/O 操作时，系统会产生一个信号通知进程。这一特性，也被称为信号驱动 I/O，仅对特定类型的文件有效，诸如终端、FIFOS 及 socket。
- O_CLOEXEC   为新（创建）的文件描述符启用 close-on-flag 标志（FD_CLOEXEC）。使用 O_CLOEXEC 标志（打开文件），可以免去程序执行 fcntl()的 F_GETFD和 F_SETFD 操作来设置 close-on-exec 标志的额外工作。
- O_CREAT     如果文件不存在，将创建一个新的空文件。即使文件以只读方式打开，此标志依然有效。如果在 open()调用中指定 O_CREAT 标志，那么还需要提供 mode 参数，否则，会将新文件的权限设置为栈中的某个随机值。
- O_DIRECT    无系统缓冲的文件 I/O 操作。
- O_DIRECTORY    如果 pathname 参数并非目录，将返回错误（错误号 errno 为 ENOTDIR）。这一标志是专为实现 opendir()函数（18.8 节）而设计的扩展标志。为使 O_DIRECTORY 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏。
- O_DSYNC     根据同步 I/O 数据完整性的完成要求来执行文件写操作。
- O_EXCL      此标志确保了调用者（open( )的调用进程）就是创建文件的进程。检查文件存在与否和创建文件这两步属于同一原子操作。
- O_LARGEFILE   支持以大文件方式打开文件。
- O_NOATIME     在读文件时，不更新文件的最近访问时间。要使用该标志，要么调用进程的有效用户 ID 必须与文件的拥有者相匹配，要么进程需要拥有特权
  （CAPFOWNER）。否则，open()调用失败，并返回错误，错误号 errno 为EPERM。
- O_NOCTTY     如果正在打开的文件属于终端设备，ONOCTTY 标志防止其成为控制终端
- O_NOFOLLOW     通常，如果 pathname 参数是符号链接，open()函数将对 pathname 参数进行解引用。一旦在 open()函数中指定了 O_NOFOLLOW 标志，且 pathname 参数属于符号链接，则 open()函数将返回失败（错误号 errno 为ELOOP）。此标志在特权程序中极为有用，能够确保 open()函数不对符号链接进行解引用。
- O_NONBLOCK   以非阻塞方式打开文件。
- O_SYNC    以同步 I/O 方式打开文件。
- O_TRUNC    如果文件已经存在且为普通文件，那么将清空文件内容，将其长度置 0。在 Linux 下使用此标志，无论以读、写方式打开文件，都可清空文件内容（在这两种情况下，都必须拥有对文件的写权限）。

### 读取文件内容：read()

```c
#include<unistd.h>
ssize_t read(int fd,void*buffer,size_t count);
```

count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。

系统调用不会分配内存缓冲区用以返回信息给调用者。所以，必须预先分配大小合适的缓冲区并将缓冲区指针传递给系统调用。与此相反，有些库函数却会分配内存缓冲区用以返回信息给调用者。

如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。

当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会出现 read()调用读取的字节数小于请求字节数的情况。

### 数据写入文件：write()

write()系统调用将数据写入一个已打开的文件中。

```c
#include<unisted.h>
ssize_t write(int fd,void*buffer,size_t count);
```

buffer 参数为要写入文件中数据的内存地址，count参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。
如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。

### 关闭文件：close() 

close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将自动关闭其已打开的所有文件描述符

```c
#include<unistd.h>
int close(int fd);
```

### 改变文件偏移量：lseek() 

对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 read()或 write()操作的文件起始位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。

文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。

针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。

offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型数。）whence 参数则表明应参照哪个基点来解释 offset 参数，应为下列其中之一：

- SEEK_SET    将文件偏移量设置为从文件头部起始点开始的 offset 个字节。
- SEEK_CUR    相对于当前文件偏移量，将文件偏移量调整 offset 个字节.
- SEEK_END    将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。

lseek()调用成功会返回新的文件偏移量。

### 文件空洞

如果程序的文件偏移量已然跨越了文件结尾，然后再执行 I/O 操作，将会发生什么情况？
read()调用将返回 0，表示文件结尾。有点令人惊讶的是，write()函数可以在文件结尾后的任意位置写入数据。

从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。

然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。

### 通用 I/O 模型以外的操作：ioctl()

ioctl()系统调用又为执行文件和设备操作提供了一种多用途机制。

```c
#include<sys/ioctl.h>
int ioctl(int fd,int request,...);//...表示任何数据类型
```

## 深入探究文件 I/O

### 原子操作和竞争条件

所有系统调用都是以原子操作方式执行的。内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。

原子性是某些操作得以圆满成功的关键所在。特别是它规避了竞争状态。竞争状态是这样一种情形：操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程获得 CPU 使用权的先后相对顺序。

## LINUX李慧琴

### 标准I/O

I/O：是一切实现的基础，包含stdio标准I/O和sysio系统调用I/O。**两者都可实现时优先使用stdio(移植性好以及合并系统调用）**

stdio: FILE类型贯穿其中 

 fopen():  

```c
#include <stdio.h>
FILE *fopen(const char *pathname, const char *mode);
//mode是权限，成功返回FILE*，失败NULL并设置errno
//errno是全局变量,用perror()可以打印出错原因
//strerror(int errnum);
//返回的指针放在堆上
//如果有互逆操作，则返回的指针一定在堆上
   FILE *fdopen(int fd, const char *mode);

   FILE *freopen(const char *pathname, const char *mode, FILE *stream);;  
```

  fclose();  fgetc();   fputc();  

  fread();   fwrite()    不建议一次读多个对象，最好单字节单字节来读

 printf();   scanf();     用fprintf()更好，scanf()里慎用%s，无法预判字符串有多大

  fseek()定位文件指针位置;    ftell()反映文件位置指针位置;  文件不能超过2g

 rewind()将文件位置指针重新指向一个流;    fflush()刷新一个流;

getline将malloc和realloc封装起来便能成一个功能;

  ssize_t getline(char **lineptr, size_t *n, FILE *stream);//一级指针的地址

### 缓冲区刷新

缓冲区作用：大多数情况下是号是，合并系统调用

行缓冲：换行时刷新，满了刷新，强制刷新（标准输出是这样的，因为是终端设备）

全缓冲：满了刷新，强制刷新（默认，只要不是终端设备）

无缓冲：如stderr,需要立即输出内容

setvbuf修改缓冲模式

### 命令行

如果用上命令行则一定要判断：

```c
if(argc<2){
    fprintf(stderr,"Usag...\n");
    exit(1);
}
```

### 临时文件

暂时储存的文件。

1.如何不冲突

2.及时销毁

tmpnam

tmpfile

### 文件/系统调用I/O

文件描述符fd是在系统调用I/O中贯穿始终的类型

- 文件描述符的概念：整型数，是数组下标，文件描述符优先使用当前可用范围内最小的（数组最大为1024）

  fd是0,1,2。stream是stdio,stdout,stderr。

- 文件I/O操作：open（变参实现的）,close,read,write,    lseek=fseek+ftell;

  r->O_RDONLY(read only)

  r+->O_RDWR

  w->O_WRONLY(write only)    |O_CREAT(create)     |O_TRUNC(截断清空)

  w+->O_RDWR      |O_TRUNC     |O_CREAT

  buffer是写的缓冲区，写的加速机制；cache是读的缓冲区，读的加速机制。

  block是阻塞，noblack是非阻塞。取决于函数打开方式。

  sync同步

- 将文件I/O和标准I/O区别:文件I/O响应速度快，标准I/O吞吐量大。标准I/O和文件I/O不可混用。

  转换：fileno将标准转换为文件I/O，fdopen同理

- I/O效率问题：存在拐点

- 文件共享：多个任务共同操作一个文件或者协同完成任务。

- 原子操作：不可分割的操作

  作用：解决竞争和冲突。如tmpnam

- 程序重定向：dup,dup2；

- 同步：sync(同步内核层面的buffer和cache)

  fsync,fdatasync

- fcntl():文件描述符所变的魔术几乎都来源于该函数;

- iocti():设备相关内容;

- /dev/fd/目录：虚目录，显示的是当前进程的文件描述符信息

### 文件系统

#### 目录和文件

**获取文件属性（类ls的实现，myls）**

stat:通过文件路径获取文件属性，面对符号链接获取的是所指向的文件的属性

fstat：通过文件描述符获取文件属性

lstat：面对符号链接文件时获取的是符号链接文件的属性

d目录文件|c字符设备文件|b跨设备文件|-常规文件|l符号链接文件|s网络套接字socket文件|p管道pipe文件

**文件访问权限:**st_mode是一个16位的位图，用于表示文件类型，文件访问权限以及特殊权限位

**umask**

作用：防止产生权限过松的文件

**文件权限的更改/管理**

chomd和fchomd可以改变文件权限信息

**粘住位**

t位：保留文件使用痕迹

**文件系统：FAT，UFS**

文件系统：文件或数据的存储和管理

**硬链接，符号链接**

ln创建硬链接。符号链接类似于windows下的快捷方式，以l开头

硬链接与目录项是同义词，且建立硬链接有限制：不能给分区建立，不能给目录建立。符号链接优点：可跨分区，可给目录建立。

link,unlink,remove,rename

**utime**

可以更改文件的最后读的时间和最后修改的时间

**目录的创建和销毁**

mkdir

rmdir

**更改当前工作路径**

cd是用chdir封装的

pwd获取当前路径

**分析目录/读取目录内容**

glob:解析模式或者是通配符

opendir();

closedir();

readdir();

rewinddir();

seekdir();

telldir();

du可以显示出文件所占磁盘空间大小

#### 系统数据文件和信息

1./ect/passwd

getpwuid();

getpwnam();

2./ect/group

getgrgid();

getgrgrnam();

3/etc/shadow

getspnam();

crypt();

getpass();

4.时间戳

time();

gmtime();

localtime();

mktime();

strftime();

#### 进程环境

1.main函数

2.进程的终止：

正常终止：

main函数return--正常终止

调用exit

调用—exit或—Exit

最后一个线程从启动例程返回

最后一个线程调用pthread_exit

异常终止：

调用abort

接到一个信号并终止

最后一个线程对其取消请求作出响应

atexit:钩子函数,防止内存泄漏

3.命令行参数的分析

getopt();解析命令行选项

getopt_long();分析长格式

#### 库

动态库

静态库

手工装载库：内核当中模块的实质是插件

dlopen()

dlclose()

dlerror()